---
layout: default
---

# 마이크로서비스 아키텍처의 4가지 복원력 패턴


## 시스템 안정성을 위한 필수 전략

클라우드 기반 마이크로서비스 환경에서 원격 서비스의 성능 저하는 단순한 문제가 아닙니다. 이러한 문제는 감지하기 어려울 뿐만 아니라, 전체 애플리케이션 생태계에 연쇄 효과를 일으킬 수 있습니다. 보호 장치가 없다면, 단일 서비스의 성능 저하가 여러 애플리케이션을 빠르게 마비시킬 수 있습니다.

특히 **마이크로서비스 아키텍처**는 수많은 세밀한 분산 서비스로 구성되어 있고, 사용자의 트랜잭션을 완료하기 위해 다양한 인프라 구성 요소가 관여하기 때문에 이러한 유형의 장애에 취약합니다.

> **복원력 패턴은 마이크로서비스 아키텍처에서 가장 중요한 측면 중 하나입니다.**
> 이러한 패턴들은 시스템이 장애 상황에서도 안정적으로 동작할 수 있도록 보장하며, 사용자에게 일관된 경험을 제공하는 핵심 요소입니다.
---

## 클라이언트 측 복원력 패턴이란?

클라이언트 측 복원력 소프트웨어 패턴은 **원격 리소스(다른 마이크로서비스 호출이나 데이터베이스 조회)**의 클라이언트가 오류나 성능 저하로 인해 원격 리소스가 실패할 때 크래시되지 않도록 보호하는 데 중점을 둡니다.

- 이러한 패턴은 **클라이언트가 빠르게 실패**하도록 하여 데이터베이스 연결이나 스레드 풀과 같은 귀중한 리소스를 소모하지 않게 합니다.
- 또한 성능이 저하된 원격 서비스의 문제가 클라이언트의 소비자들에게 **"upstream"**로 확산되는 것을 방지합니다.
---
## 1. 클라이언트 측 로드 밸런싱 (Client-side Load Balancing)

### 개념과 목적

- **클라이언트 측 로드 밸런싱**은 클라이언트가 서비스 디스커버리 에이전트(예: Netflix Eureka)에서 서비스의 모든 개별 인스턴스를 조회하고, 해당 서비스 인스턴스의 물리적 위치를 캐싱하는 패턴입니다.
- 서비스 소비자가 서비스 인스턴스를 호출해야 할 때, 클라이언트 측 로드 밸런서는 유지하는 서비스 위치 풀에서 위치를 반환합니다.
- 클라이언트 측 로드 밸런서가 서비스 클라이언트와 서비스 소비자 사이에 위치하기 때문에, 로드 밸런서는 서비스 인스턴스가 오류를 발생시키거나 성능이 저하되는지 감지할 수 있습니다.
### 동작 방식

> 클라이언트 측 로드 밸런서가 문제를 감지하면, 해당 서비스 인스턴스를 사용 가능한 서비스 위치 풀에서 제거하고 향후 호출이 해당 서비스 인스턴스에 도달하지 않도록 방지합니다.
1. 서비스 인스턴스 목록을 서비스 디스커버리에서 조회 및 캐싱
2. 요청 시, 인스턴스 풀에서 정상 인스턴스를 선택해 호출
3. 장애 인스턴스는 풀에서 제거하여 추가 장애 확산 방지

---
## 2. 서킷 브레이커 (Circuit Breaker)

분산 환경에서는 어플리케이션이 원격 리소스나 서비스를 호출하는 경우가 많고 이러한 호출에서 오류가 일시적이거나 장시간 발생할 수 있다. 재시도 패턴은 일반적으로 일시적인 오류에 사용되며, 어플리케이션이 작업이 성공할 때까지 재시도할 수 있도록 한다. 그러나 지속적인 재시도로 문제 해결이 되지 않은 상황도 있으므로 보다 전략적인 접근이 필요하다. 예를 들어 전자상거래의 결제 서비스가 완전히 중단된 경우 결제 처리를 계속 재시도 하는 것보다 장애를 신속하게 인지하고 적절한 조치를 취하는것이 바람직하고 이런 문제를 Circuit Breaker로 해결 할 수 있다. 이 패턴은 오류를 해결하는 데 시간이 오래 걸릴 수 있는 시나리오에서 유용하며, 자주 오류가 발생하는 작업의 리소스 낭비를 방지한다.

### 개념과 목적

- **서킷 브레이커 패턴**은 전기 회로 차단기를 모델로 하여, 장애가 감지되면 연결을 끊어 시스템 전체의 손상을 방지합니다.
- 소프트웨어에서는 원격 서비스 호출을 모니터링하다가, 호출이 너무 오래 걸리거나 실패가 누적되면 자동으로 차단합니다.

### 동작 방식

Circuit Breaker는 원격 접속 실패 횟수가 특정 임계값에 도달하면 정의된 시간 동안 더이상 동작하지 않도록 한다. 해당 시간 동안 오프라인 서버에 대한 모든 요청은 실패하고, 해당 시간이 지나면 제한된 수의 요청이 통과하도록 허용하고, 해당 요청이 성공하면 원래 상태로 복구한다.    

서킷 브레이커는 세 가지 상태를 가집니다:
         
![image](https://github.com/low-hill/Knowledge/assets/6086626/32a8cf92-7a44-44a8-a564-b3e7f6d4f50b)

서킷 브레이커는 **3가지 상태**를 가집니다:

| 상태         | 설명                                                         |
| ------------ | ------------------------------------------------------------ |
| **Closed**   | 정상 상태, 모든 요청이 원격 서비스로 전달됨                  |
| **Open**     | 장애 감지, 모든 요청이 즉시 실패                             |
| **Half-Open**| 복구 시도, 일부 요청만 허용하여 정상 여부 확인               |


* 실패 횟수 카운트(Close 상태): Close상태일 때는 정상 작동으로 요청을 통과 시킨다. 이때 마이크로서비스 요청에 대한 실패가 카운트 된다.    
* 실패 횟수 > 임계값(Open 상태): 실패 횟수가 임계값을 초과하면 회로가 Open 상태가 되어 요청이 서비스에 도달하지 못하도록 차단되며, 실패 응답을 반환한다. 이후 서버가 정상적으로 복구되면 Half open 상태로 변경된다.   
* 제한된 요청 테스트 및 성공 확인 (Half open 상태): 이 상태에서는 제한된 수의 요청을 통과시키고 응답에 성공하면 Close 상태로 돌아간다. 이때 요청이 실패하면 다시 Open 상태로 돌아간다.
### 주요 이점

- **빠른 실패 (Fail Fast)**
  - 원격 서비스가 성능 저하를 겪을 때 애플리케이션이 빠르게 실패하여 일반적으로 전체 애플리케이션을 종료시키는 리소스 고갈 문제를 방지합니다.
- **우아한 실패 (Fail Gracefully)**
  - 타임아웃과 빠른 실패를 통해 우아하게 실패하거나 사용자의 의도를 수행하기 위한 대안 메커니즘을 찾을 수 있는 능력을 제공합니다.
- **원활한 복구 (Recover Seamlessly)**
  - 서킷 브레이커 패턴이 중재자 역할을 하면서 요청된 리소스가 다시 온라인 상태가 되었는지 주기적으로 확인하고 인간의 개입 없이 접근을 다시 활성화할 수 있습니다.

---
## 3. 폴백 처리 (Fallback Processing)

### 개념과 목적

- **폴백 패턴**은 원격 서비스 호출이 실패할 때 예외를 발생시키는 대신, 대안 코드 경로를 실행하여 다른 방법으로 작업을 시도합니다.
- 예를 들어, 다른 데이터 소스에서 데이터를 조회하거나, 요청을 큐에 넣어 나중에 처리할 수 있습니다.

### 실제 예시

예를 들어, 사용자의 행동을 모니터링하고 구매할 수 있는 다른 아이템에 대한 추천을 제공하는 전자상거래 사이트가 있다고 가정해보겠습니다.

- 일반적으로 사용자의 과거 행동을 분석하고 해당 특정 사용자에게 맞춤화된 추천 목록을 반환하는 마이크로서비스를 호출합니다. 
- 그러나 선호도 서비스가 실패하면, 폴백은 모든 사용자 구매를 기반으로 한 더 일반적인 선호도 목록을 검색하는 것일 수 있습니다. 이 데이터는 완전히 다른 서비스와 데이터 소스에서 올 수 있습니다.

### 폴백 전략의 유형

1. **캐시된 데이터 사용**: 이전에 성공적으로 가져온 데이터를 사용
2. **기본값 반환**: 미리 정의된 기본 응답 제공
3. **대체 서비스 호출**: 동일한 기능을 제공하는 다른 서비스 사용
4. **비동기 처리**: 요청을 큐에 넣고 나중에 처리
---

## 4. 벌크헤드 (Bulkheads)

### 개념과 목적

- **벌크헤드 패턴**은 선박의 방수 격벽에서 유래한 개념으로, 시스템 내 리소스를 격리하여 하나의 장애가 전체 시스템으로 확산되는 것을 방지합니다. 

선박은 완전히 격리되고 방수된 벌크헤드라는 구획으로 나뉩니다. 선체가 관통되더라도 하나의 벌크헤드가 물을 관통이 발생한 선박의 해당 영역에 국한시키고 전체 선박이 물로 가득 차서 침몰하는 것을 방지합니다.

- 동일한 개념을 여러 원격 리소스와 상호작용해야 하는 서비스에 적용할 수 있습니다. 벌크헤드 패턴을 사용할 때, 원격 리소스에 대한 호출을 자체 스레드 풀로 분리하여 하나의 느린 원격 리소스 호출 문제가 전체 애플리케이션을 마비시킬 위험을 줄입니다.

- 마이크로서비스 환경에서 벌크헤드 패턴은 **리소스 격리**를 통해 시스템의 안정성을 보장합니다. 하나의 서비스나 외부 의존성이 문제를 일으킬 때, 그 영향이 전체 시스템으로 확산되는 것을 방지하는 것이 핵심 목적입니다.

### 동작 방식
1. **리소스 분리**: 각 외부 의존성에 대해 독립적인 스레드 풀 생성
2. **격리된 실행**: 각 서비스 호출이 해당 전용 스레드 풀에서 실행
3. **장애 격리**: 하나의 서비스 문제가 다른 서비스에 영향을 주지 않음
4. **부분적 가용성**: 일부 서비스가 실패해도 다른 기능은 계속 제공

> 스레드 풀이 서비스의 벌크헤드 역할을 하고 각 원격 리소스는 격리되고 스레드 풀에 할당됩니다. 하나의 서비스가 느리게 응답하면 해당 유형의 서비스 호출에 대한 스레드 풀이 포화 상태가 되어 요청 처리를 중단할 수 있습니다. 서비스를 스레드 풀에 할당하면 병목 현상을 우회하여 다른 서비스가 포화 상태가 되지 않도록 할 수 있습니다.

### 벌크헤드 구현

마이크로서비스 기반 애플리케이션에서는 특정 작업을 완료하기 위해 여러 마이크로서비스를 호출해야 하는 경우가 많습니다. 벌크헤드 패턴을 사용하지 않으면, 이러한 호출들은 컨테이너 전체의 요청 처리를 위해 예약된 동일한 스레드에서 실행됩니다. 

> **문제 상황**: 높은 부하에서 하나의 서비스가 느려지면, 모든 스레드가 해당 서비스 응답을 기다리게 되고, 결국 컨테이너가 크래시될 수 있습니다.

벌크헤드 패턴은 원격 리소스 호출을 자체 스레드 풀로 격리시켜서, 단일 서비스의 문제가 컨테이너를 크래시시키지 않도록 보장합니다. 벌크헤드 패턴은 주로 두 가지 방식으로 구현됩니다. 이러한 구현을 사용하여 동시 실행 수를 제한할 수 있습니다:

#### 세마포어 벌크헤드 (Semaphore Bulkhead)
* 세마포어 격리 접근 방식을 사용하여 서비스에 대한 동시 요청 수를 제한합니다. 한계에 도달하면 요청 거부를 시작합니다.

#### 스레드 풀 벌크헤드 (Thread Pool Bulkhead)
* 경계가 있는 큐와 고정된 스레드 풀을 사용합니다. 이 접근 방식은 풀과 큐가 모두 가득 찰 때만 요청을 거부합니다.

### 벌크헤드의 이점

- **격리 (Isolation)**: 하나의 서비스 문제가 다른 서비스에 영향을 주지 않음
- **리소스 보호 (Resource Protection)**: 스레드 풀과 연결 풀을 보호
- **부분적 가용성 (Partial Availability)**: 일부 서비스가 실패해도 다른 서비스는 계속 작동

---
## 참고 자료

* Newman, S. (2021). *Spring Microservices in Action, Second Edition*. Manning Publications.
* [Circuit Breaker](https://martinfowler.com/bliki/CircuitBreaker.html)
* [Circuit Breaker Pattern (Design Patterns for Microservices)](https://medium.com/geekculture/design-patterns-for-microservices-circuit-breaker-pattern-276249ffab33#id_token=eyJhbGciOiJSUzI1NiIsImtpZCI6IjFmNDBmMGE4ZWYzZDg4MDk3OGRjODJmMjVjM2VjMzE3YzZhNWI3ODEiLCJ0eXAiOiJKV1QifQ.eyJpc3MiOiJodHRwczovL2FjY291bnRzLmdvb2dsZS5jb20iLCJhenAiOiIyMTYyOTYwMzU4MzQtazFrNnFlMDYwczJ0cDJhMmphbTRsamRjbXMwMHN0dGcuYXBwcy5nb29nbGV1c2VyY29udGVudC5jb20iLCJhdWQiOiIyMTYyOTYwMzU4MzQtazFrNnFlMDYwczJ0cDJhMmphbTRsamRjbXMwMHN0dGcuYXBwcy5nb29nbGV1c2VyY29udGVudC5jb20iLCJzdWIiOiIxMDQxODYyMjY5NTg0MzkzNTcxMDEiLCJlbWFpbCI6Imp4eTUxMzBAZ21haWwuY29tIiwiZW1haWxfdmVyaWZpZWQiOnRydWUsIm5iZiI6MTcwNDk0NTAxOCwibmFtZSI6Iuq5gOyghOyYgSIsInBpY3R1cmUiOiJodHRwczovL2xoMy5nb29nbGV1c2VyY29udGVudC5jb20vYS9BQ2c4b2NKTUxjS2dIS0RjQ2VQcUFLeUNPdWJzaC1OcnFPT0VhX282UHBlTVBRYko9czk2LWMiLCJnaXZlbl9uYW1lIjoi7KCE7JiBIiwiZmFtaWx5X25hbWUiOiLquYAiLCJsb2NhbGUiOiJ6aC1DTiIsImlhdCI6MTcwNDk0NTMxOCwiZXhwIjoxNzA0OTQ4OTE4LCJqdGkiOiJlZTc4ZjlmNWFhNDNlZjZmNGM1YThjODM2YWFjMjlmOTBiZjU0MTQ0In0.DuOL6tJICSLfy67R0WMCsU7MHaaqd1DoQPY7ncsi66Zb7tQ9poAgDCT0MjUn08sl33W3IeBPxk3j1NBqDkon7WlQXfQhpbIppPOX_AQPZTnie70GPFQ5YuzxCChm_7vMWT-Q1psHguZ93A6JV91HbhwwYDrjaNn5bkO0QLolUzCfVS7pug8JSn6PHb28OMHGuLCF_zYZ99fw9RyiAPxBvFwirh5gD1UQpiZeiCR9289mS_W5kywgCy29DHEgYsxL74-LwvA6x5Zh1Bi9NTxdOdPiwFqq5bAffpq-ZwwrO1mOuARu27dHj3224wQvOoHnsVD6zM77sqCwgifFts-D6A)
* [Using the circuit breaker pattern with AWS Step Functions and Amazon DynamoDB](https://aws.amazon.com/ko/blogs/compute/using-the-circuit-breaker-pattern-with-aws-step-functions-and-amazon-dynamodb/)
* [Error Handling in Microservices: A Guide to Circuit Breaker Pattern](https://dip-mazumder.medium.com/best-practices-for-error-handling-a-guide-to-circuit-breaker-patterns-41d45ffc02ac)
* [Spring Cloud Circuit Breaker Guide](https://spring.io/guides/gs/cloud-circuit-breaker/)
