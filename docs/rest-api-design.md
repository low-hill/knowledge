---
layout: default
---
# REST API 설계 베스트 프랙티스

## 서론

REST API는 현대 웹 서비스의 핵심 구성 요소로, 잘 설계된 API는 개발자 경험을 향상시키고 시스템의 유지보수성을 높입니다. 이 글에서는 REST API를 설계할 때 고려해야 할 핵심적인 베스트 프랙티스에 대해 알아보겠습니다.

## 1. 리소스 네이밍: 동사가 아닌 명사 사용하기

RESTful API에서는 엔드포인트 경로에서 리소스의 이름을 지정할 때 동사가 아닌 명사를 사용해야 합니다. HTTP 메서드가 이미 동사를 포함하고 있기 때문에, 리소스 이름은 명사로 표현하는 것이 좋습니다.

**예시:**

- `GET /licenses` (REST 규칙 준수)
- `GET /getLicenses` (REST 규칙에 위반)

위의 예시에서는 CRUD 오퍼레이션 중 읽기 오퍼레이션만 보여주고 있습니다. 나머지 오퍼레이션들을 설계한다면 다음과 같은 엔드포인트 구조가 될 것입니다:

- `POST /licenses`: 새 라이선스를 생성합니다.
- `PATCH /licenses/{license_key}`: 특정 라이선스의 일부를 업데이트합니다.
  - 여기서 `{license_key}`는 경로 파라미터로, 라이선스 컬렉션 내에서 고유한 식별자 역할을 합니다.
  - 각 라이선스는 고유한 키를 가지며, 이 호출은 주어진 라이선스에 대한 업데이트를 수행합니다.
  - 참고: GitHub는 리소스 전체를 교체할 때 `PUT`을 사용합니다.
- `DELETE /licenses/{license_key}`: 특정 라이선스 정보를 삭제합니다.

이렇게 HTTP 메서드와 명사형 리소스 경로를 함께 사용하면 어떤 작업을 수행하는지 명확하게 표현할 수 있습니다.

## 2. 컬렉션 리소스명은 복수형 사용하기

엔드포인트 경로에서 컬렉션을 나타내는 리소스명은 항상 복수형을 사용해야 합니다. 이는 RESTful API에서 일반적으로 채택된 컨벤션으로, 컬렉션과 개별 항목을 명확히 구분하는 데 도움이 됩니다.

**예시:**

- `GET /licenses` (컬렉션 조회)
- `POST /licenses` (새 항목 생성)
- `GET /licenses/{id}` (특정 항목 조회)
- `PATCH /licenses/{id}` (특정 항목 부분 수정)
- `DELETE /licenses/{id}` (특정 항목 삭제)

## 3. HATEOAS (Hypermedia as the Engine of Application State) 적용하기

HATEOAS는 API 응답에 다른 리소스에 대한 링크를 포함하는 방식으로, 클라이언트가 동적으로 API를 탐색할 수 있게 해줍니다.

**장점:**

- REST 클라이언트가 URL을 직접 구성할 필요가 없음
- 엔드포인트 경로가 변경되어도 클라이언트 코드 수정 불필요

## 4. API 버전 관리

API 버전 관리는 하위 호환성을 유지하면서 API를 발전시키는 데 필수적입니다. API는 시간이 지남에 따라 지속적으로 개선되지만, 기존 사용자들이 여전히 이전 버전을 사용하고 있을 수 있기 때문에 여러 버전의 API를 동시에 지원해야 할 수 있습니다. API 버전 관리의 주요 방법은 다음과 같습니다:

### 헤더를 통한 버저닝

```
Accept: application/vnd.github.v3+json
```

이 접근 방식의 장점은 기본 버전을 설정할 수 있다는 점입니다. Accept 헤더가 없는 경우 기본 버전으로 안내할 수 있습니다. 그러나 버전 관리 헤더를 사용하는 REST 클라이언트가 최근 API 업그레이드 후에 업데이트되지 않으면 기능 장애로 이어질 수 있습니다. 따라서 버전 관리 헤더를 사용하는 것이 좋습니다.

### 엔드포인트 경로를 통한 버저닝

```
https://api.example.com/v1/resource
```

이 방식은 기본 버전 관리를 기본적으로 제공하지 않지만, 요청 포워딩과 같은 방법을 통해 이러한 제한을 극복할 수 있습니다. 클라이언트는 항상 의도한 API 버전을 명시적으로 사용하게 됩니다.

위의 두 가지 접근 방식 중 선호하는 방식을 선택할 수 있지만, 중요한 점은 항상 버전 관리를 사용해야 한다는 것입니다.

## 5. 중첩된 리소스

관계가 있는 리소스는 중첩된 구조로 표현할 수 있습니다. 이는 리소스 간의 계층 관계를 명확하게 보여주며, API의 직관성을 높여줍니다.

### 중첩된 리소스 접근

일반적으로 상위-하위 관계가 명확하고, 하위 리소스가 상위 리소스의 컨텍스트 안에서만 의미가 있는 경우 중첩된 구조를 사용합니다.

**예시: 고객과 주소**

- `GET /customers/1/addresses` (고객 1의 모든 주소 조회)
- `POST /customers/1/addresses` (고객 1에 새 주소 추가)
- `GET /customers/1/addresses/2` (고객 1의 2번 주소 조회)

> 그러나 리소스가 여러 컨텍스트에서 재사용되거나, 자체적인 정체성을 가진 경우에는 독립적인 리소스로 접근하는 것이 더 적절할 수 있습니다.

1. **리소스가 여러 도메인에서 재사용되는 경우**

   - 주소는 고객뿐만 아니라 주문, 배송지 등 여러 곳에서 참조될 수 있습니다.
   - 이럴 때는 주소를 독립적인 리소스로 관리하는 것이 더 효율적입니다.
2. **마이크로서비스 아키텍처에서의 분리**

   - 주문과 결제가 서로 다른 도메인 서비스로 분리된 경우, 각 서비스는 자체적인 리소스 경로를 가져야 합니다.

두 방식을 HATEOAS와 결합하면 클라이언트가 동적으로 API를 탐색할 수 있습니다.
**예시: HATEOAS 응답**

```json
{
  "id": 123,
  "customerId": 1,
  "status": "PAID",
  "amount": 15000,
  "_links": {
    "self": { 
      "href": "/orders/123",
      "method": "GET"
    },
    "update": {
      "href": "/orders/123",
      "method": "PUT"
    },
    "customer": {
      "href": "/customers/1",
      "method": "GET"
    },
    "payments": {
      "href": "/payments?orderId=123",
      "method": "GET"
    }
  }
}
```

## 6. API 보안

안전한 API를 설계하기 위한 권장사항은 다음과 같습니다:

1. 암호화된 통신

- HTTPS 사용: 암호화된 통신을 위해 항상 HTTPS 사용해야 합니다.

2. **OWASP API 보안 위협 대응**

   - OWASP의 주요 API 보안 위협 및 취약점을 살펴보고 대응해야 합니다.
   - API 보안 확인 사이트:
     - [OWASP API Security Project](https://owasp.org/www-project-api-security/)
     - [GitHub 저장소](https://github.com/OWASP/API-Security)
3. 인증 및 인가

- 상태 비저장(stateless) 인증: REST API는 상태를 유지하지 않는(stateless) 특성을 가지므로, 세션이나 쿠키 대신 JWT(JSON Web Tokens)나 OAuth 2.0 기반 토큰을 사용한 인증 방식을 구현해야 합니다.

## 7. 문서화

- 항상 최신 버전의 API 문서 유지
- 샘플 코드와 예제 제공
- 변경 이력 및 사용 중단(deprecation) 공지
- 버전별 변경 사항 상세 설명

## 8. 권장되는 상태 코드 준수

일반적으로 사용되는 REST 응답 상태 코드를 정리한 목록이다. 상태 코드 전체 목록은 [RFC 7231](https://tools.ietf.org/html/rfc7231)을 참고한다.

### 성공적인 응답 (2xx)

| 상태 코드          | 설명                                                                                                                            |
| ------------------ | ------------------------------------------------------------------------------------------------------------------------------- |
| `200 OK`         | 요청이 성공적으로 처리됨                                                                                                        |
| `201 Created`    | 새로운 리소스가 성공적으로 생성됨                                                                                               |
| `202 Accepted`   | 요청이 접수되었으나 처리가 완료되지 않음. 서버가 요청을 수락했지만 일괄 처리와 같이 즉시 응답을 보낼 수 없는 경우 (비동기 처리) |
| `204 No Content` | 요청은 성공했으나 반환할 컨텐츠가 없음                                                                                          |

### 리다이렉션 (3xx)

| 상태 코드            | 설명                                                             |
| -------------------- | ---------------------------------------------------------------- |
| `304 Not Modified` | 캐싱을 사용. 서버가 클라이언트에 리소스가 수정되지 않았다고 응답 |

### 클라이언트 오류 (4xx)

| 상태 코드                  | 설명                                                                             |
| -------------------------- | -------------------------------------------------------------------------------- |
| `400 Bad Request`        | 매개변수가 올바르지 않거나 누락되었거나 요청 자체가 불안전하여 실패한 오페레이션 |
| `401 Unauthorized`       | 인증 실패                                                                        |
| `403 Forbidden`          | 권한 없음                                                                        |
| `404 Not Found`          | 요청한 리소스를 찾을 수 없음 (존재하지 않는 경로 또는 삭제된 리소스)             |
| `405 Method Not Allowed` | 요청한 리소스에 대한 메소드가 허용되지 않아 실패                                 |
| `409 Conflict`           | 리소스 상태 충돌 (예: 이미 존재하는 리소스 생성 시도, 참조 무결성 위반)          |
| `429 Too Many Requests`  | 과도한 요청으로 인한 요청 한도 초과                                              |

### 서버 오류 (5xx)

| 상태 코드                     | 설명                                                                |
| ----------------------------- | ------------------------------------------------------------------- |
| `500 Internal Server Error` | 서버 내부 오류                                                      |
| `502 Bad Gateway`           | 업스트림 서버 호출이 실패                                           |
| `503 Service Unavailable`   | 서버에서 예상치 못한 일이 발생하여 실패(과부하 혹은 서비스 실패 등) |

## 9. 캐싱 보장

HTTP는 자제적으로 캐싱 매커니즘을 제공한다. 응답을 받은 클라이언트는 캐싱 관련 헤더가 추가된 응답으로 유효성을 검사혀 캐시된 응답을 사용할지 혹은 호출할지 확인합니다. 다음은 응답에 추가 헤더를 제공하는 두가지 방법입니다.

### ETag 사용

ETag(Entity Tag)는 리소스의 버전을 식별하는 고유한 해시 값 또는 체크섬 값으로, 리소스의 표현(응답 본문)이 변경될 때마다 함께 변경됩니다. 클라이언트는 이 값을 사용하여 캐시된 리소스의 최신 여부를 효율적으로 확인할 수 있습니다.

**작동 방식:**

1. 서버는 리소스와 함께 ETag 헤더를 응답으로 전송합니다.
2. 클라이언트는 이후 요청 시 `If-None-Match` 헤더에 이 ETag 값을 포함시킵니다.
3. 서버는 현재 리소스의 ETag와 비교하여:
   - ETag가 일치하면 `304 Not Modified` 상태 코드로 응답하여 캐시를 재사용하도록 지시합니다.
   - ETag가 다르면 새로운 리소스와 함께 업데이트된 ETag를 반환합니다.

```
ETag: "33a64df551425fcc55e4d42a148795d9f25f89d4"
If-None-Match: "33a64df551425fcc55e4d42a148795d9f25f89d4"
```

### Last-Modified 헤더 사용

Last-Modified는 ETag와 유사한 방식으로 동작하지만, 해시 값 대신 리소스가 마지막으로 수정된 시간을 RFC-1123 형식으로 표기합니다. 이 방식은 ETag보다 정확도가 떨어지므로, 보조적인 메커니즘으로 사용하는 것이 좋습니다.
**작동 방식:**

1. 서버는 리소스와 함께 Last-Modified 헤더를 응답으로 전송합니다.
2. 클라이언트는 이후 요청 시 `If-Modified-Since` 헤더에 이 타임스탬프 값을 포함시킵니다.
3. 서버는 리소스의 마지막 수정 시간을 `If-Modified-Since` 헤더의 값과 비교하여:
   - 리소스가 수정되지 않았다면 `304 Not Modified` 상태 코드로 응답합니다.
   - 리소스가 수정되었다면 새로운 Last-Modified 헤더와 함께 업데이트된 리소스를 반환합니다.

```
Last-Modified: Wed, 21 Oct 2015 07:28:00 GMT
If-Modified-Since: Wed, 21 Oct 2015 07:28:00 GMT
```

## 10. 요청 제한(Rate limit)

API 과도한 사용을 방지하기 위해 요청 제한을 구현하는 것은 매우 중요합니다. 요청 한도를 초과한 경우 HTTP 상태 코드 `429 Too Many Requests`가 반환됩니다. 현재는 요청 한도에 도달하기 전에 클라이언트에게 경고를 보내는 표준 방법은 없지만, 다음과 같은 응답 헤더를 통해 관련 정보를 전달하는 것이 일반적입니다:

### 주요 Rate Limit 헤더

| 헤더 이름                 | 설명                                                        | 예시 값        |
| ------------------------- | ----------------------------------------------------------- | -------------- |
| `X-RateLimit-Limit`     | 현재 기간 동안 허용된 총 요청 수                            | `60`         |
| `X-RateLimit-Remaining` | 현재 기간 내 남은 요청 수                                   | `55`         |
| `X-RateLimit-Reset`     | 현재 기간이 초기화될 때까지의 초 단위 시간 (Unix Timestamp) | `1601299930` |
| `X-RateLimit-Used`      | 현재 기간 내 사용된 요청 수                                 | `5`          |

### GitHub API 응답 예시

```http
HTTP/1.1 200 OK
X-RateLimit-Limit: 60
X-RateLimit-Remaining: 55
X-RateLimit-Reset: 1601299930
X-RateLimit-Used: 5
Content-Type: application/json

{
  "data": { ... }
}
```

## 결론

이 글에서 소개한 REST API 디자인 가이드라인을 따르면 보다 일관적이고 사용하기 쉬우며 확장 가능한 API를 구축할 수 있습니다. API는 단순히 기능을 제공하는 것을 넘어 개발자 경험까지 고려해야 하는 제품이라는 점을 기억하세요.

## 참고 자료

- [GitHub REST API 문서](https://docs.github.com/en/rest)
- [REST API Tutorial](https://restfulapi.net/)
- [Modern API Development with Spring and Spring Boot](https://www.packtpub.com/product/modern-api-development-with-spring-and-spring-boot/9781800562479)
