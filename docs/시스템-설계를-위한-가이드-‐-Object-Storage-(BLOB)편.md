# Object Storage (BLOB)란 무엇인가?

Object Storage, 또는 BLOB (Binary Large Object) 저장소는 방대한 비정형 데이터를 효율적으로 저장하고 관리하도록 설계된 스토리지 유형입니다. 

미디어 처리, 클라우드 환경에서 대용량 데이터(massive datasets)를 처리하거나 이를 위한 시스템을 설계할 때, Object Storage를 고려하는 것이 필수적입니다. Object Storage는 다음과 같은 대표적인 서비스가 있습니다.

- **Amazon S3** — 가장 광범위하게 사용되는 Object Storage 중 하나로, 대용량 파일을 저장하고 빠르게 검색할 수 있도록 지원하는 Amazon의 Simple Storage Service입니다.
  
- **Google Cloud Storage** — Google이 제공하는 객체 스토리지 서비스로, 대규모 데이터 저장 및 관리를 위한 효율적인 솔루션을 제공합니다.
  
- **Azure Blob Storage** — Microsoft Azure의 Blob Storage 서비스로, 비정형 데이터의 저장과 액세스를 지원하며 클라우드 기반 애플리케이션의 데이터 관리에 최적화된 성능을 제공합니다.

위의 클라우드 서비스들은 모두 대규모 데이터를 효율적으로 저장, 관리할 수 있는 Object Storage를 제공하며, 특히 웹 서비스, 대규모 애플리케이션, 데이터 분석 시스템 등에 최적화되어 있습니다.

***

# Object Storage에서의 Object의 개념

Object는 단순히 하나의 데이터 덩어리로, 이미지, 비디오 또는 가상 머신(Virtual Machine)과 같은 다양한 형태로 존재할 수 있습니다. 각 Object는 기본적으로 세 가지 주요 요소로 구성됩니다:
- **데이터(Data)** — 실제로 저장되는 binary 콘텐츠입니다.
- **고유 식별자 (Unique Identifier)** — 저장소 시스템 내에서 Object의 위치를 나타내는 고유 주소입니다. Object Storage 시스템에서 객체를 식별하고 접근하는 데 중요한 역할을 합니다.
  
- **메타데이터 (Metadata)** — Object에 대한 부가 정보로 파일명, 유형, 크기, 생성 날짜와 같은 속성들이 포함됩니다. 메타데이터는 객체를 효율적으로 관리하고 검색하는 데 중요한 역할을 합니다.


아래 표는 Object Storage 메타데이터의 필드에 대한 정보로, 각 필드의 용도와 클라이언트가 수정 가능한지 여부를 명확히 제시합니다.

| **Name**            | **Description**                                                                                                                                                                 | **User Modifiable** |
|---------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------|
| **Date**            | 요청이 발생한 시점의 날짜와 시간을 나타내며, 이는 클라이언트와 서버 간의 요청 시간 동기화를 위해 사용됩니다.                                      | No                   |
| **Cache-Control**   | 객체의 캐싱 정책을 지정하기 위한 일반 헤더 필드입니다. 이 필드를 통해 클라이언트가 객체의 캐싱 유지 시간이나 캐시 사용 여부를 제어할 수 있습니다.                          | Yes                  |
| **Content-Disposition** | 객체의 표시 방식에 대한 정보를 담고 있으며, 객체를 클라이언트에게 어떻게 표시할지를 결정합니다. 일반적으로 다운로드 시 파일 이름 지정과 같은 프레젠테이션 속성을 정의합니다.        | Yes                  |
| **Content-Length**  | 객체의 크기를 바이트 단위로 나타내는 필드로, 전송 중인 데이터의 전체 크기를 명시합니다. 클라이언트는 이를 통해 전송된 데이터가 완전한지 확인할 수 있습니다.               | No                   |
| **Content-Type**    | 객체의 MIME 유형을 정의하여 데이터의 형식을 클라이언트에 전달합니다. 이를 통해 클라이언트는 객체가 이미지, 텍스트, JSON 등 어떤 형식인지 인식하고 적절히 처리할 수 있습니다. | Yes                  |
| **Last-Modified**   | 객체가 생성되었거나 마지막으로 수정된 날짜를 나타냅니다. 클라이언트는 이 정보를 사용하여 데이터의 최신성을 확인할 수 있습니다. 멀티파트 업로드의 경우, 이 필드는 첫 업로드가 시작된 시점을 나타냅니다. | No                   |


***
# Object Storage vs. 데이터베이스

일반적으로 이미지나 비디오 파일 같은 대용량 파일을 데이터베이스에 직접 저장하지 않고, 대신 URI(파일 경로)와 메타데이터만 데이터베이스에 저장하며, 실제 파일은 Object Storage에 보관합니다. 이유는 대용량 파일을 데이터베이스에 저장할 경우, 성능 저하가 발생하고 쿼리 실행 속도가 느려지기 때문입니다.    
      
데이터베이스는 정형화된 데이터를 구조적으로 관리하고, 빠르게 접근해야 하는 메타데이터와 관계형 데이터를 처리하는 데 적합합니다. 반면 Object Storage는 대용량의 비정형 데이터를 효율적으로 저장하고, 필요 시 신속하게 검색할 수 있습니다.

따라서, 시스템 설계 시 중요한 메타데이터는 데이터베이스에 저장하고, 대용량 파일 자체는 Object Storage에 저장함으로써 데이터베이스의 성능 저하를 방지하고, Object Storage의 확장성과 속도를 동시에 누릴 수 있습니다. 이를 통해 데이터 관리와 성능 측면에서 최적화된 아키텍처를 구성할 수 있습니다.

# Object Storage vs. 파일 시스템
파일 시스템은 로컬 스토리지와 데이터 정리에 적합하지만, Object Storage만큼 확장성이 뛰어나지 않습니다. 이는 파일 시스템이 **계층적 구조**로 이루어져 있기 때문입니다. 파일 시스템은 폴더 구조를 통해 트리 형태로 데이터를 구성하므로, 대규모 데이터를 빠르게 확장하는 데 제약이 따릅니다. 반면 Object Storage는 **평면적이고 비정형적인 구조**를 가지고 있어 계층을 두지 않고 데이터를 저장합니다. 이로 인해 빠르고 유연한 데이터 확장이 가능하며, 대용량 데이터의 검색 및 접근 속도 면에서도 뛰어난 성능을 발휘합니다.
![image](https://github.com/user-attachments/assets/e91b6c7d-aa43-46f5-841c-5a64aba41b0e)

***

# Object Storage에서의 폴더 개념

Object Storage에서 모든 객체는 폴더와 관계없이 평면적인 구조로 저장됩니다.

AWS S3와 같은 많은 플랫폼에서는 **객체 이름에 구분자**(delimiter)를 사용하여 폴더처럼 보이도록 하는 기능을 제공합니다. 예를 들어, “photos/vacation/beach.jpg”와 같이 객체 이름에 슬래시(“/”)를 사용해 경로를 구분하고 이를 폴더 구조로 표현하는 방식입니다. 그러나 이러한 방식은 사용자의 편의를 위해 제공되는 시각적 요소일 뿐, 실제로는 Object Storage에 폴더 개념이 존재하지 않습니다. 

## 고유 식별자

앞서 언급한 것처럼, 각 객체는 **고유 식별자**를 부여받습니다. 버킷(bucket)은 객체의 컨테이너 역할을 하며, 해당 버킷 내에서 객체의 이름은 고유해야 합니다. 

특히 AWS S3의 경우, **버킷 이름은 모든 AWS 계정에 걸쳐 고유해야 하므로** 객체 이름도 전역적으로 유일성을 갖습니다. 즉, 동일한 이름의 버킷이 AWS 전체에 중복되지 않도록 보장되며, 이로 인해 버킷 내 객체의 고유성이 보장됩니다. 이러한 특성 덕분에 객체를 효율적으로 검색하고 관리할 수 있습니다.

***

# Object Storage 연동

대부분의 Object Storage는 객체와 연동할 수 있도록 **RESTful API**를 제공합니다. 이 API를 통해 HTTP 요청(예: PUT, GET, DELETE)을 사용하여 데이터를 관리할 수 있습니다.

- **객체 업로드**  
  예를 들어, S3 스토리지에 객체를 업로드하려면 POST 요청을 사용하거나 AWS Management Console을 직접 통해 파일을 업로드할 수 있습니다.

- **객체 조회**  
  마찬가지로, 업로드된 객체는 GET 요청을 통해 조회할 수 있습니다.

- **객체 수정** [DELETE & POST]
  Object Storage에서 객체를 수정할 때는 보통 기존 객체의 일부만을 변경하는 대신 **전체 객체를 새 버전으로 대체**하는 방식을 사용합니다. 파일 시스템과 달리, Object Storage에서는 객체의 일부만 수정할 수 없기 때문에 수정하려면 DELETE 요청으로 기존 객체를 삭제하고, POST 요청으로 수정된 새 객체를 업로드하는 것이 일반적입니다.

이와 같은 작업을 간편하게 수행할 수 있도록 여러 프로그래밍 언어에 맞는 라이브러리와 SDK도 지원됩니다.

***

# Summary

Object Storage객체는 고유 식별자를 기반으로 객체에 빠르게 접근할 수 있으며, 대부분의 Object Storage는 **분산 아키텍처**를 채택하여 다수의 스토리지 노드에 트래픽을 분산시킵니다.

또한, 자주 접근되는 객체는 **캐시**에 저장되어 더욱 빠른 검색이 가능하도록 최적화됩니다. 

많은 Object Storage 플랫폼은 보안 기능도 제공합니다. 예를 들어, ** signed URL과 서명된 쿠키**를 통해 객체에 대한 접근 권한을 제어할 수 있습니다. 
***

* [Object Storage (BLOBs) Explained for System Design](https://levelup.gitconnected.com/object-storage-blobs-in-system-design-4d6ddf0241d1)